use std::io::{Result, Write};
use std::path::PathBuf;

use crate::core::config::{
    Compartment, Config, Constraint, General, Mask, Point, RearrangeMethod, Rule, Segment, Shape,
    Space,
};

pub fn write<W: Write>(config: &Config, w: &mut W) -> Result<()> {
    let Config {
        general,
        space,
        includes,
        constraints,
        compartments,
        segments,
    } = config;

    // Write a comment header about this file.
    writeln!(w, "# Generated by bentopy.")?;
    writeln!(w)?;

    {
        // General section.
        let General {
            title,
            seed,
            bead_radius,
            max_tries_mult,
            max_tries_rot_div,
            rearrange_method,
        } = general;

        section(w, "general")?;
        if let Some(val) = title {
            field(w, "title", format_string(val))?
        }
        if let Some(val) = seed {
            field(w, "seed", val)?
        }
        if let Some(val) = bead_radius {
            field(w, "bead-radius", val)?
        }
        if let Some(val) = max_tries_mult {
            field(w, "max-tries-mult", val)?
        }
        if let Some(val) = max_tries_rot_div {
            field(w, "max-tries-rot-div", val)?
        }
        if let Some(val) = rearrange_method {
            field(w, "rearrange", rm(val))?
        }

        writeln!(w)?; // Spacing newline.
    }

    {
        // Space section.
        let Space {
            dimensions,
            resolution,
            periodic,
        } = space;

        section(w, "space")?;
        if let Some(val) = dimensions {
            field(w, "dimensions", point(val))?
        }
        if let Some(val) = resolution {
            field(w, "resolution", val)?
        }
        if let Some(val) = periodic {
            field(w, "periodic", val)?
        }

        writeln!(w)?; // Spacing newline.
    }

    // Includes section.
    section(w, "includes")?;
    for include in includes {
        include_entry(w, include)?;
    }
    writeln!(w)?; // Spacing newline.

    // Compartments section.
    section(w, "compartments")?;
    for compartment in compartments {
        compartment_entry(w, compartment)?;
    }
    writeln!(w)?; // Spacing newline.

    // Constraints section.
    section(w, "constraints")?;
    for constraint in constraints {
        constraint_entry(w, constraint)?;
    }
    writeln!(w)?; // Spacing newline.

    // Segments section.
    section(w, "segments")?;
    for segment in segments {
        segment_entry(w, segment)?;
    }
    writeln!(w)?; // Spacing newline.

    Ok(())
}

fn section<W: Write>(w: &mut W, header: &'static str) -> Result<()> {
    writeln!(w, "[ {header} ]")
}

fn field<W: Write, D: std::fmt::Display>(w: &mut W, name: &'static str, value: D) -> Result<()> {
    writeln!(w, "{name}\t{value}")
}

// TODO: This could be done with a std::fmt::Display impl on RearrangeMethod.
fn rm(val: &RearrangeMethod) -> &'static str {
    match val {
        RearrangeMethod::Moment => "moment",
        RearrangeMethod::Volume => "volume",
        RearrangeMethod::BoundingSphere => "bounding-sphere",
        RearrangeMethod::None => "none",
    }
}

fn point(point: &Point) -> String {
    let [x, y, z] = point;
    format!("{x}, {y}, {z}")
}

fn format_string(s: &str) -> String {
    format!(r#""{s}""#)
}

fn format_path(path: &PathBuf) -> String {
    // TODO: This really makes me think we should mave it to Vec<String>.
    format_string(path.to_str().expect("TODO"))
}

fn list<T: std::fmt::Display>(items: &[T]) -> String {
    items
        .iter()
        .map(ToString::to_string)
        .collect::<Vec<_>>()
        .join(", ")
}

fn include_entry<W: Write>(w: &mut W, include: &std::path::PathBuf) -> Result<()> {
    writeln!(w, "{}", format_path(include))
}

fn compartment_entry<W: Write>(w: &mut W, compartment: &Compartment) -> Result<()> {
    let Compartment { id, mask } = compartment;
    let mask = match mask {
        Mask::All => "is all".to_string(),
        Mask::Voxels(path) => format!("from {}", format_path(path)),
        Mask::Shape(Shape::Sphere { center, radius }) => {
            format!("as sphere at {center} with radius {radius}")
        }
        Mask::Shape(Shape::Cuboid { start, end }) => {
            format!("as cuboid from {start} to {end}")
        }
        Mask::Combination(expr) => format!("is combination {expr}"),
    };
    writeln!(w, "{id} {mask}")
}

fn constraint_entry<W: Write>(w: &mut W, constraint: &Constraint) -> Result<()> {
    let Constraint { id, rule } = constraint;
    let rule = match rule {
        Rule::Limits(expr) => format!("where {expr}"),
        Rule::Within { distance, id } => format!("within {distance} of {id}"),
    };
    writeln!(w, "{id} {rule}")
}

fn segment_entry<W: Write>(w: &mut W, segment: &Segment) -> Result<()> {
    let Segment {
        name,
        tag,
        quantity,
        path,
        compartment_ids,
        rules,
    } = segment;
    let id = match tag {
        Some(tag) => format!("{name}:{tag}"),
        None => name.to_string(),
    };
    let path = format_path(path);
    let compartment_ids = list(compartment_ids);
    let rules = match rules {
        Some(rules) => format!(" satisfies {}", list(rules)),
        None => Default::default(),
    };
    writeln!(w, "{id} {quantity} from {path} in {compartment_ids}{rules}")
}
