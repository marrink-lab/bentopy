import argparse
from pathlib import Path

import MDAnalysis as mda
import numpy as np
from .utilities import voxels_to_gro
from mdvcontainment import Containers

DEFAULT_CONTAINMENT_RESOLUTION = 1.0
DEFAULT_MASK_RESOLUTION = 0.5

# TODO: Use a proper log function that is subject to the --verbose flag?
log = print


def process_labels(labels: str) -> list[int]:
    return [int(label) for label in labels.split()]


def setup_parser(parser=None):
    if parser is None:
        parser = argparse.ArgumentParser(
            description="Set up masks based on structures and compartment segmentations.",
            prog="mask",
            epilog='"Relabel, relabel, relabel."',
        )
    parser.add_argument(
        "input",
        type=Path,
        help="Input structure file to subject to segmentation.",
    )
    parser.add_argument(
        "output",
        type=Path,
        help="Output path for the resulting voxel mask.",
    )
    parser.add_argument(
        "--interactive",
        action="store_true",
        default=True,
        help="Ask for command line input at runtime.",
    )
    parser.add_argument(
        "--containment-resolution",
        default=DEFAULT_CONTAINMENT_RESOLUTION,
        type=float,
        help="Resolution for the compartment finding routine (nm).",
    )
    parser.add_argument(
        "--mask-resolution",
        default=DEFAULT_MASK_RESOLUTION,
        type=float,
        help="Voxel size (resolution) for the exported mask (nm).",
    )
    parser.add_argument(
        "--selection",
        default="not resname W ION",
        type=str,
        help="MDAnalysis selection string for the atom group over which to perform the segmentation.",
    )
    parser.add_argument(
        "--labels",
        type=process_labels,
        help="Pre-selected compartment labels, comma-separated.",
    )
    parser.add_argument(
        "--plot",
        type=Path,
        help="Optional output path for the visualization page generated by mdvcontainment during segmentation (html).",
    )
    parser.add_argument(
        "--debug-labels",
        type=Path,
        help="Write the label voxels as a gro file for inspection with molecule viewers.",
    )
    parser.add_argument(
        "--debug-voxels",
        type=Path,
        help="Write the final voxel mask as a gro file for inspection with molecule viewers.",
    )
    parser.add_argument(
        # TODO: Currently a no-op. Will change in the future.
        "-v",
        "--verbose",
        action="store_true",
        help="Use verbose output.",
    )
    return parser


def main(args):
    structure_path = args.input
    log(f"Reading in structure from {structure_path}... ", end="")
    u = mda.Universe(structure_path)
    log(f"done. (Read {u.atoms.n_atoms} atoms.)")

    selection = u.select_atoms(args.selection)
    log(f"Selected {selection.n_atoms} atoms according to '{args.selection}'.")

    log("Calculating containment...")
    log("\n--- mdvcontainment --- 8< ---")
    containment = Containers(selection, args.containment_resolution)
    log("--- >8 --- mdvcontainment ---\n")

    log("Found the following compartments:")
    log(f"\t  root:\t{containment.get_root_components()}")
    log(f"\tleaves:\t{containment.get_leaf_components()}")
    # TODO: Add an interactive question about whether to plot and if so what path if it is not provided through the args.
    if args.plot is not None:
        log(f"Plotting to {args.plot}.")
        containment.plot(name=args.plot)

    label_array = containment.data["relabeled_combined_label_array"]
    if args.debug_labels is not None:
        labels_path = args.debug_labels
        log(f"Writing labels voxels debug file to {labels_path}... ", end="")
        voxels_to_gro(labels_path, label_array)
        log("done.")

    # TODO: Is there a neater way of getting the different labels from the Containment?
    possible_labels = np.unique(label_array)

    # TODO: Let the behavior depend on whether --interactive is set. Now we will always ask for input().
    if args.labels is None:
        log(
            "No compartment labels have been selected, yet. Select one or more to continue."
        )
        log(
            f"Options: {possible_labels}. Provide them as a space-separated list followed by a return."
        )
        labels = []
        while len(labels) == 0:
            labels.extend(map(lambda label: int(label), input("-> ").split()))
            for label in labels:
                if label not in possible_labels:
                    log(
                        f"'{label}' is not a valid compartment label. Please try again."
                    )
                    labels.clear()
                    break
    else:
        labels = args.labels
    log(f"Selected the following labels: {labels}.")

    # TODO: Reconsider if args.output should be mandatory when --interactive is also there.
    if args.output is None:
        log("Please specify an output path or name for the mask (npz).")
        mask_path = ""
        while len(mask_path) == 0:
            mask_path = input("-> ").trim()
    else:
        mask_path = args.output

    compartment = np.isin(label_array, labels)
    # TODO: Display this as % voxels as placeable space.
    contents = np.unique(compartment, return_counts=True)
    log("Selected compartment contains:")
    for thing, count in zip(*contents):
        log(f"{thing:>14}: {count}")

    # HACK: We are just assuming that args.containment_resolution and args.mask_resolution are integer-divisible by each other.
    zoom = int(args.containment_resolution / args.mask_resolution)
    log(f"Output mask resolution is set to {args.mask_resolution} nm.")
    log(f"Zoom factor from containment voxels to mask voxels is {zoom}.")
    zoomed = compartment.repeat(zoom, axis=0).repeat(zoom, axis=1).repeat(zoom, axis=2)

    log(f"Size of final voxel mask is {zoomed.shape}.")
    if args.debug_voxels is not None:
        voxels_path = args.debug_voxels
        log(f"Writing mask voxels debug file to {voxels_path}... ", end="")
        voxels_to_gro(voxels_path, zoomed)
        log("done.")
    log(f"Writing the voxel mask to {mask_path}... ", end="")
    np.savez(mask_path, zoomed)
    log("done.")
